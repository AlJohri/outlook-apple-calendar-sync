#!/usr/bin/osascript -l JavaScript

/*
Usage: ./extract.jxa

Outlook Object Model: https://docs.microsoft.com/en-us/office/vba/api/overview/outlook/object-model
*/

class OutlookCalendar {
  constructor(calendarName, calendarIndex) {
    this.app = Application("Microsoft Outlook");
    this.calendar = this.app.calendars.whose({ name: calendarName })[
      calendarIndex
    ];

    try {
      this.calendar.get();
    } catch (e) {
      throw `Could not find an Outlook calendar with name "${calendarName}" at index "${calendarIndex}".`;
    }

    if (this.calendar.calendarEvents().length === 0) {
      throw `Calendar "${calendarName} at index "${calendarIndex}" exists but has 0 events.`;
    }
  }

  getEvents({
    startTime = null,
    endTime = null,
    removeAllDay = true,
    removeMultiDay = true,
    removeRecurrence = true,
    blacklistPhrases = []
  }) {
    let critera = null;
    if (startTime || endTime) {
      let range = [];
      if (startTime) range.push({ startTime: { _greaterThan: startTime } });
      if (endTime) range.push({ endTime: { _lessThan: endTime } });
      critera = { _and: range };
    }

    let events = critera
      ? this.calendar.calendarEvents.whose(critera)()
      : this.calendar.calendarEvents();

    if (removeAllDay) {
      events = events.filter(x => !x.allDayFlag());
    }

    if (removeMultiDay) {
      const ONE_DAY = 24 * 60 * 60;
      events = events.filter(
        x => (x.endTime() - x.startTime()) / 1000 < ONE_DAY
      );
    }

    if (removeRecurrence) {
      // only keep occurrences of recurring events (i.e. isOccurance=true)
      events = events.filter(x => !x.isRecurring());
    }

    if (blacklistPhrases.length > 0) {
      events = events.filter(
        x => !any(blacklistPhrases.map(phrase => x.subject().includes(phrase)))
      );
    }

    return events;
  }
}

class AppleCalendar {
  constructor(calendarName, calendarDescription) {
    this.app = Application("Calendar");

    if (!this.app.running()) {
      this.app.launch();
      delay(1);
    }

    this.calendar = this.getOrCreateCalendar(calendarName, calendarDescription);
  }

  getOrCreateCalendar(calendarName, calendarDescription) {
    let calendar = this.app.calendars.whose({ name: calendarName })[0];
    try {
      calendar.get();
    } catch (e) {
      log(`Calendar "${calendarName}" not found.`);
      calendar = null;
    }

    if (!calendar) {
      log(`Creating calendar: "${calendarName}"`);
      calendar = this.app
        .Calendar({
          name: calendarName,
          description: calendarDescription
        })
        .make();
    }

    if (calendar.name() != calendarName) {
      throw "Something is wrong";
    }

    return calendar;
  }

  getOrCreateEvent(x) {
    const id = x.id().toString();
    let event;

    try {
      event = this.calendar.events.whose({ url: id })[0];
      event.get();
    } catch (e) {
      event = null;
    }

    if (!event) {
      log(`Creating event ${id} ${x.subject()}`);
      event = Calendar.Event({
        url: id,
        summary: x.subject(),
        startDate: x.startTime(),
        endDate: x.endTime(),
        description: x.plainTextContent(),
        alldayEvent: x.allDayFlag(),
        location: x.location()
      });
      this.calendar.events.push(event);
    } else {
      log(`Skipping event ${id} ${x.subject()}, already exists`);
    }
    return event;
  }
}

function log(...args) {
  console.log(`[${new Date()}]`, ...args)
}

function any(iterable) {
  for (var index = 0; index < iterable.length; index++) {
    if (iterable[index]) return true;
  }
  return false;
}

function getDateRange({ daysAgo, daysAhead }) {
  var endTime = new Date();
  var startTime = new Date(endTime);
  startTime.setDate(startTime.getDate() - daysAgo);
  endTime.setDate(endTime.getDate() + daysAhead);
  return {startTime, endTime};
}

function camelCase(input) {
  return input.toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
}

function parseArgs(argv) {
  const args = {};
  argv.forEach(arg => {
    if (arg.startsWith("--")) {
      arg = arg.substring(2);
      let flag = arg;
      let value = true;
      if (arg.includes("=")) {
        [flag, value] = arg.split("=");
      }
      flag = camelCase(flag);
      args[flag] = value;
    } else {
      throw `Unknown arg: ${arg}`;
    }
  });
  return args;
}

function main(argv) {

  log(`Synchronizing Outlook to Apple Calendar`)

  const defaultArgs = {
    outlookCalendarName: "Calendar",
    outlookCalendarIndex: "1",
    appleCalendarName: "Outlook Sync",
    daysAgo: 1,
    daysAhead: 7
  };

  const args = { ...defaultArgs, ...parseArgs(argv) };

  const {startTime, endTime} = getDateRange({
    daysAgo: args.daysAgo,
    daysAhead: args.daysAhead
  });

  log(`Outlook Calendar: "${args.outlookCalendarName}" at Index [${args.outlookCalendarIndex}]`)
  log(`Apple Calendar: "${args.appleCalendarName}"`)
  log(`Start Time: ${startTime} (${args.daysAgo} days ago)`)
  log(`End Time: ${endTime} (${args.daysAgo} days ahead)`)

  const outlookCalendar = new OutlookCalendar(
    args.outlookCalendarName,
    args.outlookCalendarIndex
  );

  const appleCalendar = new AppleCalendar(
    args.appleCalendarName,
    args.appleCalendarDescription || ""
  );

  const events = outlookCalendar.getEvents({
    startTime,
    endTime,
    blacklistPhrases: ["Appt"],
    removeAllDay: true,
    removeMultiDay: true,
    removeRecurrence: true
  });

  log(`${events.length} events found between ${startTime} and ${endTime}`);

  for (let event of events) {
    appleCalendar.getOrCreateEvent(event);
  }
}

function run(args) {
  const App = Application.currentApplication();
  App.includeStandardAdditions = true;

  try {
    main(args);
  } catch (e) {
    App.displayAlert(e.toString());
    throw e;
  }
}
